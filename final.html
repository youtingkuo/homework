<html><head>
<style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}
body {
  overflow: hidden;
}
</style>
</head>
<body>
<div id="info">final homework</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r76/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">
</script>
<script  src="https://rawgit.com/banksean/304522/raw/8f481c980fe34e6930d44c61c59d7851f4235a3c/perlin-noise-simplex.js"></script>

<script src="https://www.clicktorelease.com/code/bumpy-metaballs/js/MarchingCubes.js"></script>

<div id="container"></div>
<script>
var camera, scene, renderer, container;
var mesh, controls, boat, effect;
var clock = new THREE.Clock();
var start = Date.now();
var resolution, numBlobs, sign = -1;


init();
animate();

function init() { 
  var width = window.innerWidth;
  var height = window.innerHeight;

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize(width, height);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
  camera.position.set(-600, 250, -700); //-600 250 -700
  camera.lookAt(new THREE.Vector3(0, 0, 0));
	
  // spotlight
 		var light = new THREE.PointLight();
    light.position.set(400, 200, 0);
    scene.add(light);
    var light2 = light.clone();
    light2.position.set(-400, 200, 0);
    scene.add(light2);
    var light3 = light.clone();
    light3.position.set(0, 200, 400);
    //scene.add(light3);
    var light4 = light.clone();
    light4.position.set(0, 200, -400);
    //scene.add(light4);
		
  controls = new THREE.OrbitControls(camera, renderer.domElement);

	var loader = new THREE.ObjectLoader();
  loader.load ('https://youtingkuo.github.io/model/tree.json', 
  function ( obj ) {
    obj.scale.set (0.025,0.025,0.025);
  	obj.position.set(-300, 0, 380);
    obj.castShadow = true;
    obj.receiveShadow = true;
    scene.add( obj );
    var obj2 = obj.clone();
    obj2.position.set(300, 0, 380);
    scene.add(obj2);
  });

	var loader2 = new THREE.ObjectLoader();
  loader2.load ('https://youtingkuo.github.io/model/open-fishing-boat.json', 
  function ( obj ) {
  	boat = obj;
    obj.scale.set (20,20,20);
  	obj.position.set(-400, 0.1, -400); // -3.1 ~ 10.1
    obj.castShadow = true;
    obj.receiveShadow = true;
    obj.rotation.y = -Math.PI/2;
    scene.add( obj );
  });

  var meshFunc = function(u0, v0) {
    return new THREE.Vector3(1000 * u0 - 500, 
    5 * Math.sin(20 * (u0 + v0)),
    1000 * v0 - 500);
  };
  var geometry = new THREE.ParametricGeometry(meshFunc, 40, 40);
	
  THREE.ImageUtils.crossOrigin = '';
  var texture = THREE.ImageUtils.loadTexture('http://i.imgur.com/gbuuZ81.png');
  
	var material = new THREE.MeshLambertMaterial ({map: texture,  side:THREE.DoubleSide});

  mesh = new THREE.Mesh(geometry, material);
  mesh.receiveShadow = true;
  scene.add(mesh);
  
  var geometry1 = new THREE.PlaneGeometry( 2000, 2000, 32 );
	var material1 = new THREE.MeshLambertMaterial ({map: THREE.ImageUtils.loadTexture('http://i.imgur.com/oOBno2O.jpg'),  side:THREE.DoubleSide});
	cloud = new THREE.Mesh( geometry1, material1 );
  cloud.position.set(0, 600, -1000);
  scene.add(cloud);
  var cloud2 = cloud.clone();
  cloud2.position.set(1000, 600, 0);
  cloud2.rotation.y = Math.PI/2;
  scene.add(cloud2);
  var cloud3 = cloud.clone();
  cloud3.position.set(-1000, 600, 0);
  cloud3.rotation.y = Math.PI/2;
  scene.add(cloud3);
  var cloud4 = cloud.clone();
  cloud4.position.set(0, 600, 1000);
  scene.add(cloud4);
  var cloud5 = cloud.clone();
  cloud5.position.set(0, -400, 0);
  cloud5.rotation.x = Math.PI/2;
  scene.add(cloud5);
  
  renderer.shadowMapEnabled = true;
  renderer.shadowMapType = THREE.PCFShadowMap;
  window.addEventListener('resize', onWindowResize, false);
  
  container = document.getElementById('container');
  container.appendChild(renderer.domElement);
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  window.addEventListener('resize', onWindowResize, false);
  
  resolution = 30;
  numBlobs = 30;
  
  effect = new THREE.MarchingCubes(50, new THREE.MeshLambertMaterial({color: 0x6BC1FF}), true, false);
  effect.position.set(0, -400, 0);
  effect.scale.set(500, 500, 500);
  scene.add(effect);
  
  var seabed1 = new THREE.Mesh(new THREE.PlaneGeometry(1000, 500, 32), new THREE.MeshLambertMaterial ({map: THREE.ImageUtils.loadTexture('http://i.imgur.com/zj14cEM.png'), transparent: true, opacity: 0.5, side:THREE.DoubleSide}));
  seabed1.position.set(0, -250, 500);
  scene.add(seabed1);
  var seabed2 = seabed1.clone();
  seabed2.position.set(0, -250, -500);
  scene.add(seabed2);
  var seabed3 = seabed1.clone();
  seabed3.rotation.y = Math.PI/2;
  seabed3.position.set(500, -250, 0);
  scene.add(seabed3);
  var seabed4 = seabed1.clone();
  seabed4.rotation.y = Math.PI/2;
  seabed4.position.set(-500, -250, 0);
  scene.add(seabed4);
}

function updateCubes(object, time, numblobs) {

  object.reset();

  var i, ballx, bally, ballz, subtract, strength;

  subtract = 100;
  strength = 1.2 / ((Math.sqrt(numblobs) - 1) / 4 + 1);

  for (i = 0; i < numblobs; i++) {
    ballx = Math.sin(i + 1.26 * time * (1.03 + 0.5 * Math.cos(0.21 * i))) * 0.27 + 0.5;
    bally = Math.cos(i + 1.12 * time * 0.21 * Math.sin((0.72 + 0.83 * i))) * 0.27 + 0.5;
    ballz = Math.cos(i + 1.32 * time * 0.1 * Math.sin((0.92 + 0.53 * i))) * 0.27 + 0.5;
    object.addBall(ballx, bally, ballz, strength, subtract);
  }
};

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  var time = clock.getElapsedTime()*2;
  var deltaT = clock.getDelta();
  
  updateCubes(effect, .0005 * (Date.now() - start), numBlobs);
  
  var nvs = mesh.geometry.vertices.length;
  for (var i = 0; i < nvs/2.15; i++) {
    mesh.geometry.vertices[i].y = 9 * Math.sin(mesh.geometry.vertices[i].x + time);
  }
  mesh.geometry.computeFaceNormals();
  mesh.geometry.computeVertexNormals();
  mesh.geometry.normalsNeedUpdate = true;
  mesh.geometry.verticesNeedUpdate = true;
	
  if (boat !== undefined) { 
		if(boat.position.y >= 10.1 || boat.position.y <= -3.1)
      sign *= -1;
		boat.position.y += sign * 0.144; 
	}

  controls.update();
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>
</body></html>